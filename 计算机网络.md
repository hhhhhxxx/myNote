# 计算机网络

## 运输层

### 运输层协议概述

运输层向它上面的应用层提供通信服务

从运输层的角度看，通信的真正端点并不是主机而是主机中的进程。也就是说，端到端的通信是应用进程之间的通信。

### 用户数据报协议UDP

#### UDP概述

**1.UDP是无连接的**，即发送数据之前不需要建立连接（当然，发送数据结束也没有连接可以释放），因此减少了开销和发送数据之前的时延。

**2.UDP使用尽最大努力交付**，即不保证可靠交付，因此主机不需要维持复杂的连接状态表（这里面有许多参数）

**3.UDP是面向报文的**。发送方的UDP对应用程序交下来的报文，在添加首部后就向下交付IP层。UDP对应用层交下来的报文既不合并，也不拆分，而是保留这些报文的边界。应用层交给UDP多长的报文，UDP就照样发送，一次发送一个报文。

**4.UDP没有拥塞控制**，因此网络出现的拥塞不会使源主机的发送速率降低。

**5.UDP支持一对一，一对多，多对一和多对多的交互通信**。

**6.UDP的首部开销小**，只有8个字节，比TCP的20个字节的首部要短

#### UDP首部格式

![image-20220726155710489](D:\Code\myNote\计算机网络.assets\image-20220726155710489.png)

#### UDP校验和

在计算机校验和时，要在UDP用户数据报之前增加12个字节的伪首部。伪首部既不向下传送也不向上递交，而仅仅是为了计算校验和。

首先是先把全零放入检验和字段。再把伪首部以及UDP用户数据报看成是由许多16位的字串接起来的。若UDP用户数据报的数据部分不是偶数个字节，则要填入一个全零字节（但此字节不发送）。然后按二进制反码计算出这些16位字的和。将此和的二进制反码写入校验和字段后，就发送这样的UDP用户数据报。

![image-20220726155800161](D:\Code\myNote\计算机网络.assets\image-20220726155800161.png)



在接收方，把收到的UDP用户数据报连同伪首部（以及可能的填充全零字节）一起，按二进制反码求这些16位字的和。当无差错时其结果应全为1。

个人理解：校验和是所有数据反码加起来再去反码，就是和的反码，校验的时候，原来的和 加上和的反码肯定等于1咯

### 传输控制协议TCP

#### TCP概述

**1.TCP是面向连接的运输层协议。**应用程序在使用TCP协议之前，必须先建立TCP连接。在传送数据完毕后，必须释放已经建立的TCP连接。

**2.每一条TCP连接只能有两个端点，每一条TCP连接只能是点对点的（一对一）。**

**3.TCP提供可靠交付的服务。**通过TCP连接传送的数据，无差错，不丢失，不重复，并且按序到达。

**4.TCP提供全双工通信。**TCP运行通信双方的应用进程在任何时候都能发送数据。

**5.面向字节流。**TCP中的流指的是流入到进程或从进程流出的字节序列。面向字节流的含义是：虽然应用程序和TCP的交互是一次一个数据块（大小不等），但TCP把应用程序交下来的数据库仅仅看成是一连串的无结构的字节流。

#### TCP报文段的首部格式

![image-20220726165128782](D:\Code\myNote\计算机网络.assets\image-20220726165128782.png)



### 可靠传输的工作原理

#### 停止等待协议

**1.无差错情况**

A发送分组M1，发完就暂停，等待B的确认。B收到M1就向A发送确认。A在收到了对M1的确认后，就再发送下一个分组M2。

**2.出现差错**

A只要超过了一段时间仍然没有收到确认，就认为刚才发送的分钟丢失，因而重传前面发送过的分组。这就叫做超时重传

注意

- A必须暂时保留已发送的分组的副本。
- 分组和确认分组必须进行编号，明确哪一个是已经确认的分组。编号是循环使用的，32位整数
- 超时计时器设置的重传时间应当比数据在分组传输的平均往返时间更长一些。 

**3.确认丢失和确认迟到**

B所发送的对M1的确认丢失了，A在设定的超时重传时间内没有收到确认。A重传M1，B又收到了重传的分组的M1

意思是B收到两次M1，B的行动

1.丢弃这个重复的分组M1

2.向A发送确认

因为信道利用率低，所以改为流水线传输 ，发送多组分组

使用流水线传输时，使用连续ARQ协议和滑动窗口协议

![image-20220726164529615](D:\Code\myNote\计算机网络.assets\image-20220726164529615.png)



#### 连续ARQ协议 

ARQ：自动重传请求（Automatic Repeat reQuest）

![image-20220726164550592](D:\Code\myNote\计算机网络.assets\image-20220726164550592.png)



1.发送方每收到一个确认，就把发送窗口向前滑动一个分组的位置

2.接收方一般采用累积确认的方式，对按序到达的最后一个分组发送确认，即到这个分组为止的所有分组都已正确收到了

优点：容易实现

缺点：重传时需要重传发送过的分组，可能这些分组B已经收到了，只是中间断开了，有一个没收到。



### TCP可靠传输的实现

#### 已字节为单位的滑动窗口

发送窗口的三个指针

P3 - P1 = A的发送窗口

P2 - P1 = 已发送但是尚未收到确认的字节数

P3 - p2 = 允许发送但当前尚未发送的字节数（又称为可用窗口或有效窗口）

![image-20220726170506606](D:\Code\myNote\计算机网络.assets\image-20220726170506606.png)



在没有收到B的确认的情况下，A可以连续把窗口内的数据都发送出去

A的发送窗口一定不能超过B的接收窗口的数值，还要受到网络拥塞控制的制约

收到B的确认后，P1和P3可以前移，但是要保持窗口大小不变。

每发送一个分组，P2就前移，未确认分组就多一个

B只能确认有序到达的最大确认号，32,33被B收到了，B的确认号也只能是31，提前收到的暂时留在接收窗口里，等待后续数据然后一起确认



A发送缓存用来暂时存放：

1.发送应用程序传送个发送方TCP准备发送的数据。之后新来的数据

2.TCP已送出但尚未收到确认的数据。P2 - P1的数据，为重传做准备



B接收缓存用来暂时存放：

1.按序到达的、但尚未被接收应用程序读取的数据

2.未按序到达的数据



#### 流量控制

让发送方的发送速率不要太快，要让接收方来得及接收

发送方B告诉A自己的接收窗口大小进行流量控制

如果接收窗口为0，A为发送一个零窗口探测报文，对方的确认给出现在的窗口大小值

#### 拥塞控制

**1.慢开始**

由小到大逐渐增大发送窗口



**2.拥塞避免**



**3.快重传**



**4.快恢复**













