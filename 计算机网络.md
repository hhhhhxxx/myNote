# 计算机网络

## 运输层

### 运输层协议概述

运输层向它上面的应用层提供通信服务

从运输层的角度看，通信的真正端点并不是主机而是主机中的进程。也就是说，端到端的通信是应用进程之间的通信。

### 用户数据报协议UDP

#### UDP概述

**1.UDP是无连接的**，即发送数据之前不需要建立连接（当然，发送数据结束也没有连接可以释放），因此减少了开销和发送数据之前的时延。

**2.UDP使用尽最大努力交付**，即不保证可靠交付，因此主机不需要维持复杂的连接状态表（这里面有许多参数）

**3.UDP是面向报文的**。发送方的UDP对应用程序交下来的报文，在添加首部后就向下交付IP层。UDP对应用层交下来的报文既不合并，也不拆分，而是保留这些报文的边界。应用层交给UDP多长的报文，UDP就照样发送，一次发送一个报文。

**4.UDP没有拥塞控制**，因此网络出现的拥塞不会使源主机的发送速率降低。

**5.UDP支持一对一，一对多，多对一和多对多的交互通信**。

**6.UDP的首部开销小**，只有8个字节，比TCP的20个字节的首部要短

#### UDP首部格式

![image-20220726155710489](D:\Code\myNote\计算机网络.assets\image-20220726155710489.png)

#### UDP校验和

在计算机校验和时，要在UDP用户数据报之前增加12个字节的伪首部。伪首部既不向下传送也不向上递交，而仅仅是为了计算校验和。

首先是先把全零放入检验和字段。再把伪首部以及UDP用户数据报看成是由许多16位的字串接起来的。若UDP用户数据报的数据部分不是偶数个字节，则要填入一个全零字节（但此字节不发送）。然后按二进制反码计算出这些16位字的和。将此和的二进制反码写入校验和字段后，就发送这样的UDP用户数据报。

![image-20220726155800161](D:\Code\myNote\计算机网络.assets\image-20220726155800161.png)



在接收方，把收到的UDP用户数据报连同伪首部（以及可能的填充全零字节）一起，按二进制反码求这些16位字的和。当无差错时其结果应全为1。

个人理解：校验和是所有数据反码加起来再去反码，就是和的反码，校验的时候，原来的和 加上和的反码肯定等于1咯

### 传输控制协议TCP

#### TCP概述

**1.TCP是面向连接的运输层协议。**应用程序在使用TCP协议之前，必须先建立TCP连接。在传送数据完毕后，必须释放已经建立的TCP连接。

**2.每一条TCP连接只能有两个端点，每一条TCP连接只能是点对点的（一对一）。**

**3.TCP提供可靠交付的服务。**通过TCP连接传送的数据，无差错，不丢失，不重复，并且按序到达。

**4.TCP提供全双工通信。**TCP运行通信双方的应用进程在任何时候都能发送数据。

**5.面向字节流。**TCP中的流指的是流入到进程或从进程流出的字节序列。面向字节流的含义是：虽然应用程序和TCP的交互是一次一个数据块（大小不等），但TCP把应用程序交下来的数据库仅仅看成是一连串的无结构的字节流。

#### TCP报文段的首部格式

![image-20220726165128782](D:\Code\myNote\计算机网络.assets\image-20220726165128782.png)



### 可靠传输的工作原理

#### 停止等待协议

**1.无差错情况**

A发送分组M1，发完就暂停，等待B的确认。B收到M1就向A发送确认。A在收到了对M1的确认后，就再发送下一个分组M2。

**2.出现差错**

A只要超过了一段时间仍然没有收到确认，就认为刚才发送的分钟丢失，因而重传前面发送过的分组。这就叫做超时重传

注意

- A必须暂时保留已发送的分组的副本。
- 分组和确认分组必须进行编号，明确哪一个是已经确认的分组。编号是循环使用的，32位整数
- 超时计时器设置的重传时间应当比数据在分组传输的平均往返时间更长一些。 

**3.确认丢失和确认迟到**

B所发送的对M1的确认丢失了，A在设定的超时重传时间内没有收到确认。A重传M1，B又收到了重传的分组的M1

意思是B收到两次M1，B的行动

1.丢弃这个重复的分组M1

2.向A发送确认

因为信道利用率低，所以改为流水线传输 ，发送多组分组

使用流水线传输时，使用连续ARQ协议和滑动窗口协议

![image-20220726164529615](D:\Code\myNote\计算机网络.assets\image-20220726164529615.png)



#### 连续ARQ协议 

ARQ：自动重传请求（Automatic Repeat reQuest）

![image-20220726164550592](D:\Code\myNote\计算机网络.assets\image-20220726164550592.png)



1.发送方每收到一个确认，就把发送窗口向前滑动一个分组的位置

2.接收方一般采用累积确认的方式，对按序到达的最后一个分组发送确认，即到这个分组为止的所有分组都已正确收到了

优点：容易实现

缺点：重传时需要重传发送过的分组，可能这些分组B已经收到了，只是中间断开了，有一个没收到。



### TCP可靠传输的实现

#### 已字节为单位的滑动窗口

发送窗口的三个指针

P3 - P1 = A的发送窗口

P2 - P1 = 已发送但是尚未收到确认的字节数

P3 - p2 = 允许发送但当前尚未发送的字节数（又称为可用窗口或有效窗口）

![image-20220726170506606](D:\Code\myNote\计算机网络.assets\image-20220726170506606.png)



在没有收到B的确认的情况下，A可以连续把窗口内的数据都发送出去

A的发送窗口一定不能超过B的接收窗口的数值，还要受到网络拥塞控制的制约

收到B的确认后，P1和P3可以前移，但是要保持窗口大小不变。

每发送一个分组，P2就前移，未确认分组就多一个

B只能确认有序到达的最大确认号，32,33被B收到了，B的确认号也只能是31，提前收到的暂时留在接收窗口里，等待后续数据然后一起确认



A发送缓存用来暂时存放：

1.发送应用程序传送个发送方TCP准备发送的数据。之后新来的数据

2.TCP已送出但尚未收到确认的数据。P2 - P1的数据，为重传做准备



B接收缓存用来暂时存放：

1.按序到达的、但尚未被接收应用程序读取的数据

2.未按序到达的数据



#### 流量控制

让发送方的发送速率不要太快，要让接收方来得及接收

发送方B告诉A自己的接收窗口大小进行流量控制

如果接收窗口为0，A为发送一个零窗口探测报文，对方的确认给出现在的窗口大小值

#### 拥塞控制

![image-20220726201147590](D:\Code\myNote\计算机网络.assets\image-20220726201147590.png)

**1.慢开始**

由小到大逐渐增大发送窗口

​		初始拥塞窗口不超过2至4个SMSS (发送方最大报文段)

​		拥塞窗口cwnd每次的增加量 = min ( N, SMSS )

​	

个人理解：当网络通畅，上一次发送的N个分组都能确认，每次增加上一次确认的数值，即变成上一次发送窗口大小为两倍，指数级增长

**2.拥塞避免**

当超过慢开始门限ssthresh停止慢开始算法改用拥塞避免算法

​		每次发送方的拥塞窗口cwnd加1，而不是像慢开始阶段那样加倍增长

​		当网络出现了超时，发送方判断为网络堵塞，调整门限值为 ssthresh = cwnd / 2 ，同时cwnd = 1 进入慢开始阶段

**3.快重传**

发送方只要一连收到3个重复确认，就知道接收方确实没有收到报文段M3（M3在网络中丢失，网络并未拥塞），执行快重传

重新发送M3

**4.快恢复**

快恢复是在快重传的现象下，为了避免拥塞，对cwnd进行了设置

​		发送方调整门限值为ssthresh = cwnd / 2，同时设置拥塞窗口为cwnd = ssthresh，并开始拥塞避免算法



#### 三次握手

首部字段

**序号seq ：**占四个字节的符号整数 最大2^32 - 1

**确认号ack：**占四个字节，期望收到对方下一个报文段的第一个数据字节的序号

**确认ACK：**仅当ACK =  1 时确认号字段才有效，当ACK=0 时，确认号无效，TCP规定，在连接建立后所有传送的报文段都必须把ACK 置1

**同步SYN：**在建立时用来同步序号。当SYN = 1 而ACK=0时，表明这是一个连接请求报文段。对方若同意建立连接，则应在响应的报文段					中使用SYN = 1和ACK = 1

![image-20220726203831570](D:\Code\myNote\计算机网络.assets\image-20220726203831570.png)

1.A向B发出连接请求报文，SYN = 1，同时选择一个初始序号seq = x，不携带数据，A进入SYN-SENT（同步已发送）状态

2.B收到请求报文段后，如同意建立连接，则向A发送确认，SYN = 1，ACK置1，ack确认号为x+1（A下一个要发的序号），同时选择一个初始序号seq = y，不携带数据，B进入SYN-RCVD（同步收到）状态

3.A收到B的确认后，还要向B给出确认。ACK置1，ack=y+1（B下一个要发的序号），seq=x+1，A进入ESTABLISHED（已建立连接）状态



**为什么A最好还要发送一次确认呢？**

这主要是为了防止已失效连接请求报文突然又传到了B，因而产生错误

假设A向B发出了两次连接请求，第一次因为超时没有确认所有发起第二次连接请求，第二次发出的请求得到了确认，建立了连接，数据传输完毕后就释放了连接。

此时，第一次发出的连接请求因为在某些网络节点长时间滞留，并不是丢失，然后第二次连接释放后突然发送到B，B误以为A又发出一次新的连接请求（此时处于第二个步骤），假定不采用握手报文（第三个步骤），只要B发出了确认，新的连接就建立了。

A并没有发出建立连接的请求，因此不会理睬B的确认，也不会向B发送数据，B以为新的连接已经建立，并一直等待A发来数据。B的许多资源就这样白白浪费了

#### 四次挥手

首部字段

**终止FIN：**用来释放一个连接。当FIN = 1时，表示此报文段的发送方的数据已发送完毕，并要求释放运输连接。

![image-20220726210758395](D:\Code\myNote\计算机网络.assets\image-20220726210758395.png)





1.A的应用程序先向其TCP发出连接释放报文段，并停止再发送数据，主动关闭TCP连接，连接释放报文 FIN = 1，seq = u，u等于A前面已传送过的数据的最后一个字节的序号加1。A进入FIN-WAIT-1（终止等待1）状态。

2.B收到连接释放报文后即发出确认，ACK = 1，ack=u+1, seq = v ,v等于B前面已传送过的数据的最后一个字节的序号加1。B进入CLOSE-WAIT（关闭等待）状态。

3.A收到B的确认后，就进入FIN-WAIT-2（终止等待）状态，等待B发出的连接释放报文段。（半关闭状态，应用层A->B连接释放，运输层还在）

4.B发出连接释放报文FIN = 1，ACK = 1，ack = u+1(重复上一个确认号，因为A没有再发），seq = w (w不一定等于v+1，在半关闭，B->A方向可能还有数据发送），

5.A在收到B的连接释放报文后，必须对此发出确认，ACK=1，ack = w+1，seq = u+1，进入TIME-WAIT（时间等待）状态现在TCP连接还没有释放掉，必须经过**时间等待计时器**设置的时间2 MSL后（2个最长报文寿命时间，总共4分钟），A才进入CLOSED状态。



为什么A在TIME-WAIT状态后必须等待2MSL的时间呢？这有两个理由。

第一，为了保证A发送的最后一个ACK报文段能够到达B。B没有收到确认，就会重传B中间的发的两个报文（确认A释放ACK 和 自己释放FIN），A要保证收到重传报文后能够重传一次确认报文。

第二，防止“已失效的连接请求报文”出现在本链接中，再经过2MSL,，就可以使本次连接持续时间内所产生的所有报文段都从网络中消失。

