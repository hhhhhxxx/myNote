# 笔试和面试复盘

10.15 保利威



### 属于tcp协议的是



**使用TCP协议的常见端口主要有以下几种：**


（1） FTP：定义了文件传输协议，使用21端口。常说某某计算机开了FTP服务便是启动了文件传输服务。下载文件，上传主页，都要用到FTP服务。
（2） Telnet：它是一种用于远程登陆的端口，用户可以以自己的身份远程连接到计算机上，通过这种端口可以提供一种基于DOS模式下的通信服务。如以前的BBS是-纯字符界面的，支持BBS的服务器将23端口打开，对外提供服务。
（3） SMTP：定义了简单邮件传送协议，现在很多邮件服务器都用的是这个协议，用于发送邮件。如常见的免费邮件服务中用的就是这个邮件服务端口，所以在电子邮件设置-中常看到有这么SMTP端口设置这个栏，服务器开放的是25号端口。
（4） POP3：它是和SMTP对应，POP3用于接收邮件。通常情况下，POP3协议所用的是110端口。也是说，只要你有相应的使用POP3协议的程序（例如Fo-xmail或Outlook），就可以不以Web方式登陆进邮箱界面，直接用邮件程序就可以收到邮件（如是163邮箱就没有必要先进入网易网站，再进入自己的邮-箱来收信）。



### MySQL查询每年每个季度的最高成绩

```mysql
-- 查询每年每个季度的最高成绩
SELECT user_id,Max(score) as '最高分',GROUP_CONCAT(DISTINCT YEAR(stat_at),'q',QUARTER(stat_at)) as '季度'
from user_score 
GROUP BY user_id,YEAR(stat_at),QUARTER(stat_at)
```



linux命令：kill执行会怎么样

top update命令

让一个任务某个时间定时运行，输入到/data/之类的





### linux可以ssh 但是反应慢 原因和解决方法

下面说下如何解决这样的问题，最为常见的原因是



因为server的sshd会去DNS查找访问client IP的hostname，如果DNS不可用或者没有相关记录，就会耗费大量时间。



1、在server上/etc/hosts文件中把你本机的ip和hostname加入

2、在server上/etc/ssh/sshd_config文件中修改或加入UseDNS=no

3、注释掉server上/etc/resolv.conf中所有行

4、修改server上/etc/nsswitch.conf中hosts为hosts: files

5、reboot server使配置生效



### Http header什么字符

ASCII码

header中只能传输英文，如果需要传输中文，发放方需要使用URLEncoder.encode(“我是汉字”,"UTF-8") 进行编码，接收方需要使用URLDecoder.decode("待解析字符串", "UTF-8")进行解码



### 小程序为什么没有session

微信小程序不能保存Cookie，导致每次wx.request到服务端都会创建一个新的会话（传过去的sessionid会变化），小程序端就不能保持登录状态了。



面试官说因为跨域问题



### 常见的三握手四挥手



### https握手过程，交换密钥方式



TLS握手
TLS的握手阶段是发生在TCP握手之后。握手实际上是一种协商的过程，对协议所必需的一些参数进行协商。TLS握手过程分为四步，过程如下：（备注：图中加方括号的均为可选消息）



Client Hello
由于客户端(如浏览器)对一些加解密算法的支持程度不一样，但是在TLS协议传输过程中必须使用同一套加解密算法才能保证数据能够正常的加解密。在TLS握手阶段，客户端首先要告知服务端，自己支持哪些加密算法，所以客户端需要将本地支持的**加密套件(Cipher Suite)的列表**传送给服务端。除此之外，客户端还要产生一个**随机数**，这个随机数一方面需要在客户端保存，另一方面需要传送给服务端，客户端的随机数需要跟服务端产生的随机数结合起来产生后面要讲到的Master Secret。

Server Hello
上图中，从Server Hello到Server Done，有些服务端的实现是每条单独发送，有服务端实现是合并到一起发送。Sever Hello和Server Done都是只有头没有内容的数据。

服务端在接收到客户端的Client Hello之后，服务端需要将自己的**证书**发送给客户端。这个证书是对于服务端的一种认证。例如，客户端收到了一个来自于称自己是www.alipay.com的数据，但是如何证明对方是合法的alipay支付宝呢？这就是证书的作用，支付宝的证书可以证明它是alipay，而不是财付通。证书是需要申请，并由专门的数字证书认证机构(CA)通过非常严格的审核之后颁发的电子证书。颁发**证书的同时会产生一个私钥和公钥**。私钥由服务端自己保存，不可泄漏。公钥则是附带在证书的信息中，可以公开的。证书本身也附带一个证书电子签名，这个签名用来验证证书的完整性和真实性，可以防止证书被串改。另外，证书还有个有效期。

在服务端向客户端发送的证书中没有提供足够的信息的时候，还可以向客户端发送一个Server Key Exchange。

此外，对于非常重要的保密数据，服务端还需要对客户端进行验证，以保证数据传送给了安全的合法的客户端。服务端可以向客户端发出Cerficate Request消息，要求客户端发送证书对客户端的合法性进行验证。

跟客户端一样，服务端也需要产生一个随机数发送给客户端。客户端和服务端都需要使用这两个随机数来产生Master Secret。

最后服务端会发送一个Server Hello Done消息给客户端，表示Server Hello消息结束了。

Client Key Exchange
如果服务端需要对客户端进行验证，在客户端收到服务端的Server Hello消息之后，首先需要向服务端发送客户端的证书，让服务端来验证客户端的合法性。

在此之前的所有TLS握手信息都是明文传送的。在收到服务端的证书等信息之后，客户端会使用一些加密算法(例如：RSA, Diffie-Hellman)产生一个48个字节的Key，这个Key叫PreMaster Secret，很多材料上也被称作PreMaster Key, 最终通过Master secret生成session secret， session secret就是用来对应用数据进行加解密的。PreMaster secret属于一个保密的Key，只要截获PreMaster secret，就可以通过之前明文传送的随机数，最终计算出session secret，所以PreMaster secret使用RSA非对称加密的方式，使用服务端传过来的公钥进行加密，然后传给服务端。

接着，客户端需要对服务端的证书进行检查，检查证书的完整性以及证书跟服务端域名是否吻合。

ChangeCipherSpec是一个独立的协议，体现在数据包中就是一个字节的数据，用于告知服务端，客户端已经切换到之前协商好的加密套件的状态，准备使用之前协商好的加密套件加密数据并传输了。

在ChangecipherSpec传输完毕之后，客户端会使用之前协商好的加密套件和session secret加密一段Finish的数据传送给服务端，此数据是为了在正式传输应用数据之前对刚刚握手建立起来的加解密通道进行验证。

Server Finish
服务端在接收到客户端传过来的PreMaster加密数据之后，使用私钥对这段加密数据进行解密，并对数据进行验证，也会使用跟客户端同样的方式生成session secret，一切准备好之后，会给客户端发送一个ChangeCipherSpec，告知客户端已经切换到协商过的加密套件状态，准备使用加密套件和session secret加密数据了。之后，服务端也会使用session secret加密后一段Finish消息发送给客户端，以验证之前通过握手建立起来的加解密通道是否成功。

根据之前的握手信息，如果客户端和服务端都能对Finish信息进行正常加解密且消息正确的被验证，则说明握手通道已经建立成功，接下来，双方可以使用上面产生的session secret对数据进行加密传输了。

Secret Keys
上面的分析和讲解主要是为了突出握手的过程，所以PreMaster secret，Master secret，session secret都是一代而过，但是对于Https，SSL/TLS深入的理解和掌握，这些Secret Keys是非常重要的部分。所以，准备把这些Secret Keys抽出来单独分析和讲解。

我们先来看看这些Secret Keys的的生成过程以及作用流程图：



PreMaster secret
PreMaster secret是在客户端使用RSA或者Diffie-Hellman等加密算法生成的。它将用来跟服务端和客户端在Hello阶段产生的随机数结合在一起生成Master secret。在客户端使用服务端的公钥对PreMaster secret进行加密之后传送给服务端，服务端将使用私钥进行解密得到PreMaster secret。也就是说服务端和客户端都有一份相同的PreMaster secret和随机数。

PreMaster secret前两个字节是TLS的版本号，这是一个比较重要的用来核对握手数据的版本号，因为在Client Hello阶段，客户端会发送一份加密套件列表和当前支持的SSL/TLS的版本号给服务端，而且是使用明文传送的，如果握手的数据包被破解之后，攻击者很有可能串改数据包，选择一个安全性较低的加密套件和版本给服务端，从而对数据进行破解。所以，服务端需要对密文中解密出来对的PreMaster版本号跟之前Client Hello阶段的版本号进行对比，如果版本号变低，则说明被串改，则立即停止发送任何消息。

关于PreMaster Secret(Key)的计算请参考《Https SSL/TLS PreMaster/Master Secret(Key)计算》。

Master secret
上面已经提到，由于服务端和客户端都有一份相同的PreMaster secret和随机数，这个随机数将作为后面产生Master secret的种子，结合PreMaster secret，客户端和服务端将计算出同样的Master secret。

Master secret是有系列的hash值组成的，它将作为数据加解密相关的secret的Key Material。Master secret最终解析出来的数据如下：



其中，write MAC key，就是session secret或者说是session key。Client write MAC key是客户端发数据的session secret，Server write MAC secret是服务端发送数据的session key。MAC(Message Authentication Code)，是一个数字签名，用来验证数据的完整性，可以检测到数据是否被串改。关于MAC的工作原理详见MAC。

关于Session Secret(Key)的计算请参考《Htttps SSL/TLS Session Secret(Key)计算》。

应用数据传输
在所有的握手阶段都完成之后，就可以开始传送应用数据了。应用数据在传输之前，首先要附加上MAC secret，然后再对这个数据包使用write encryption key进行加密。在服务端收到密文之后，使用Client write encryption key进行解密，客户端收到服务端的数据之后使用Server write encryption key进行解密，然后使用各自的write MAC key对数据的完整性包括是否被串改进行验证。



### ping www.baidu.com命令经历了什么

1、主机查找本地系统Hosts文件的DNS缓存，如果存在www.baidu.com对应的IP,则获取IP；

2、若本地系统没有对应IP，主机操作系统生成一个DNS查询报文，将字符串www.baidu.com放入DNS报文段中。该DNS报文段被放置于53号（DNS服务器）目的端口的UDP报文段。该UDP报文则被放入具有IP目的地址（在网络初始化阶段DHCP ACK返回的DNS服务器地址）和源IP地址的IP数据报中；

3、主机将包含DNS请求报文的数据报放入一个以太网帧中。该帧将发送（在链路层寻址）到虚拟机网络中的网关路由器。网络初始化时知道了虚拟机局域网的网关路由器的IP地址，但是仍不知道该网关路由器的MAC地址，主机将使用ARP协议；

4、主机生成一个具有目的IP地址的ARP查询报文，将该ARP报文放置在一个具有广播目的地址（FF:FF:FF:FF:FF:FF）的以太网帧中并向交换机发送该以太网帧，交换机将该帧交付给所有连接的设备，包括网关路由器；

4、网关路由器接收到包含该ARP查询报文的帧，发现在ARP查询报文中目标IP地址匹配接口的IP地址，网关路由器将准备一个ARP回答，指示该接口的MAC地址对应目标IP地址。它将ARP回答放在一个以太网帧中，目的地址为主机MAC地址，并向交换机发送该帧，交换机向主机发送该帧；

5、主机接收包含ARP回答的帧，并从ARP回答报文中抽取网关路由器的MAC地址；

6、主机向交换机发送2中包含DNS查询报文的帧，交换机将该帧发送给网关路由器

7、网关路由器接受该帧并抽取包含DNS查询的数据报。路由器查找该数据报的目的地址，并根据其转发表（根据自身域内协议和英特网域间协议BGP填写）决定该数据报最佳转发链路，经过数个路由器重复网关路由器的过程，最终到达DNS服务器。DNS服务器抽取出DNS查询报文，在数据库中查找www.baisu.com及其IP地址的DNS源记录。该DNS服务器形成一个包含这种主机名到IP地址映射的DNS回答报文，并将该报文放到UDP报文段中，报文段放入寻址到主机的IP数据报中，反向转发到主机。

8、若DNS服务器不存在www.baidu.com的记录与其对应的IP地址，则本地DNS服务器将主机报文发送到根DNS服务器，根服务器匹配com后缀并向本地DNS服务器返回负责com的TLD的IP地址列表。本地服务器再次向列表的TLD DNS服务器之一发送请求，该TLD服务器利用权威DNS服务器的Ip地址进行响应，最后本地DNS服务器直接向权威服务器发起请求，权威DNS服务器将返回响应报文，逐层返回给本地主机。至此，主机获得www.baidu.com对应的IP地址。

9、主机通过www.baidu.com的IP地址的子网掩码判断出该地址跨网段并将ICMP类型8编码0的请求回显查询报文封装成IP数据报，源地址为主机的IP地址，目的地址时域名对应的IP地址。主机再将该IP数据报封装成MAC帧，源地址是主机的MAC地址，目的地址是网关路由器的MAC地址

10、主机发送MAC帧，经过交换机发送到网关路由器，路由器解封装该帧，发现MAC目的地址是自己，而IP目的地址不是自己，将帧的MAC源地址改为自己的MAC地址，根据路由协议计算出最短路径的下一个网关路由器的MAC地址（若不知道MAC地址，则如同3、4那样经由ARP协议获取下一个网关的MAC地址），作为该帧的目的地址，直至最后一个网关路由器接收到该帧，找到子网内IP地址符合目的IP地址的主机www.baidu.com，将该IP数据包转发给该主机。主机接受ICMP请求报文后，生成一个ICMP类型0编码0的回显应答报文，经过多层封装，由ARP协议的相互学习性获得的MAC地址，经由多个网关路由器，转送到本地主机，本地主机接受到该ICMP报文后，证明两个主机ping通。

ICMP协议：ICMP是TCP/IP协议族的一个子协议，工作在网络互联层（网络层）。ICMP协议是一种面向无连接的协议，用于传输出错报告控制信息。用于在IP主机、路由器之间传递控制消息。控制消息是指网络通不通、主机是否可达、路由是否可用等网络本身的消息。这些控制消息虽然并不传输用户数据，但是对于用户数据的传递起着重要的作用。



### 浏览器输入域名后按回车发生了什么

详细讲解如下：
第一步：用户输入网址
第二步：进行DNS域名解析，将地址解析成ip地址
浏览器DNS域名解析；
系统（本地）NDS域名解析；
路由器DNS域名解析；
网络运行商DNS域名解析；
递归DNS域名解析；

第三步：建立TCP连接（TCP三次握手）
第一次握手：浏览器（客户端）向服务端发起，告诉服务求，我准备好了，请求建立连接，你也准备一下；
第二次握手：服务器向浏览器发起，告诉浏览器，我准备好了，我同意建立连接，你发送过来吧；
第三次握手：浏览器向服务器发起，告诉服务器，我发送了，你接受吧；

第四步：请求报文（发送请求）

第五步：响应报文（响应请求）
第六步：HTML渲染
遇到HTML标签，浏览器会通知HTML解析器去进行解析，最终生成Token并生成dom树；
遇到style/link标签，浏览器会通知css解析器去进行解析，最终生成cssom树；
遇到script标签，浏览器会通识javascript解析器去进行解析，包括事件处理，操作dom，修改css等；
解析完成之后dom树和cssom树会生成一个渲染树，根据计算来实现页面布局；
最后渲染到页面；

第七步：断开TCP连接（TCP的四次挥手）
第一次挥手由浏览器向服务器发起，告诉服务器，我请求发送完毕（请求报文），你准备关闭吧；
第二次挥手由服务器向浏览器发起，告诉浏览器，我收到请求了（请求报文），你也准备关闭吧；
第三次挥手由服务器向浏览器发起，告诉浏览器，我的响应报文也发送完毕，你准备关闭吧；
第四次挥手由浏览器向服务器发起，告诉服务器，我收到响应了（响应报文），你关闭吧；



Spring ioc 控制翻转 思想



Spring aop思想



### MySQL为什么不用哈希索引



1、区间值难找。因为单个值计算会很快，而找区间值，比如 100 < id < 200 就悲催了，需要遍历全部hash节点。 

2、排序难。通过hash算法，也就是压缩算法，可能会很大的值和很小的值落在同一个hash桶里，比如一万个数压缩成1000个数存到hash桶里，也就是会产生hash冲突。



### MySQL保证数据存储到硬盘不出错

MySQL关系型数据库，是日志先行策略（Write-Ahead Logging），只要binlog和redo log日志能保证持久化到磁盘，我们就能确保MySQL异常重启后，数据不丢失。



redo log重做日志文件，只记录事务对数据页做了哪些修改，它记录的是数据修改之后的值，**支持崩溃恢复crash-safe**。



### Redis缓存如何保证数据一致性 Redis 删除失败怎么办

想要保证缓存与数据库的双写一致，一共有4种方式，即4种同步策略：
**先更新缓存，再更新数据库；**
**先更新数据库，再更新缓存；**
**先删除缓存，再更新数据库；**
**先更新数据库，再删除缓存。**

那么我们需要做的就是根据不同的场景来使用合理的方式来解决数据问题。

**第一种：先删除缓存，再更新数据库**

在出现失败时可能出现的问题：

1：线程A删除缓存成功，线程A更新数据库失败；

2 ：线程B从缓存中读取数据；由于缓存被删，进程B无法从缓存中得到数据，进而从数据库读取数据；此时数据库中的数据更新失败，线程B从数据库成功获取旧的数据，然后将数据更新到了缓存。
最终，缓存和数据库的数据是一致的，但仍然是旧的数据。

**第二种：先更新数据库，再删除缓存**

假设这会有两个请求，一个请求A做查询操作，一个请求B做更新操作，那么会有如下情形产生

（1）缓存刚好失效
（2）请求A查询数据库，得一个旧值
（3）请求B将新值写入数据库
（4）请求B删除缓存
（5）请求A将查到的旧值写入缓存
如果发生上述情况，确实是会发生脏数据。
然而，发生这种情况的概率又有多少呢？
发生上述情况有一个先天性条件，就是步骤（3）的写数据库操作比步骤（2）的读数据库操作耗时更短，才有可能使得步骤（4）先于步骤（5）。
数据库的读操作的速度远快于写操作的（不然做读写分离干嘛，做读写分离的意义就是因为读操作比较快，耗资源少），因此步骤（3）耗时比步骤（2）更短，这一情形很难出现。
先更新数据库，再删缓存依然会有问题，不过，问题出现的可能性会因为上面说的原因，变得比较低。

**第三种：给所有的缓存一个失效期**

第三种方案可以说是一个大杀器，任何不一致，都可以靠失效期解决，失效期越短，数据一致性越高。但是失效期越短，查数据库就会越频繁。因此失效期应该根据业务来定。
1.并发不高的情况：
读: 读redis->没有，读mysql->把mysql数据写回redis，有的话直接从redis中取；
写: 写mysql->成功，再写redis；
2.并发高的情况：
读: 读redis->没有，读mysql->把mysql数据写回redis，有的话直接从redis中取；
写：异步话，先写入redis的缓存，就直接返回；定期或特定动作将数据保存到mysql，可以做到多次更新，一次保存；

**第四种：加锁，使线程顺序执行**

如果一个服务部署到了多个机器，就变成了分布式锁，或者是分布式队列按顺序去操作数据库或者 Redis，带来的副作用就是：数据库本来是并发的，现在变成串行的了，加锁或者排队执行的方案降低了系统性能，所以这个方案看起来不太可行。

**第五种：采用双删**

先删除缓存，再更新数据库，当更新数据后休眠一段时间再删除一次缓存。

方案推荐两种：

1：项目整合quartz等定时任务框架，去实现延时3–5s再去执行最后一步任务 。（推荐使用）
2：创建线程池，线程池中拿一个线程，线程体中延时3-5s再去执行最后一步任务（不能忘了启动线程）

**第六种：异步更新缓存(基于订阅binlog的同步机制)**

MySQL binlog增量订阅消费+消息队列+增量数据更新到redis读Redis

热数据基本都在Redis写MySQL:增删改都是操作MySQL更新Redis数据：MySQ的数据操作binlog，来更新到Redis：

1)数据操作主要分为两大块：一个是全量(将全部数据一次写入到redis)一个是增量(实时更新)。

这里说的是增量,指的是mysql的update、insert、delate变更数据。

2)读取binlog后分析 ，利用消息队列,推送更新各台的redis缓存数据。
这样一旦MySQL中产生了新的写入、更新、删除等操作，就可以把binlog相关的消息推送至Redis，Redis再根据binlog中的记录，对Redis进行更新。
其实这种机制，很类似MySQL的主从备份机制，因为MySQL的主备也是通过binlog来实现的数据一致性。
这里可以结合使用canal(阿里的一款开源框架)，通过该框架可以对MySQL的binlog进行订阅，而canal正是模仿了mysql的slave数据库的备份请求，使得Redis的数据更新达到了相同的效果。
当然，这里的消息推送工具你也可以采用别的第三方：kafka、rabbitMQ等来实现推送更新Redis。



### 内存管理做什么

操作系统的内存管理主要负责内存的分配与回收（malloc 函数：申请内存，free 函数：释放内存），另外地址转换也就是将逻辑地址转换成相应的物理地址等功能也是操作系统内存管理做的事情。

### 两个线程 总共只有4g内存，申请4g,会成功吗



要看操作系统限制



32 位系统的内核空间占用 1G，位于最高处，剩下的 3G 是用户空间；
64 位系统的内核空间和用户空间都是 128T，分别占据整个内存空间的最高和最低处，剩下的中间部分是未定义的。

现在可以回答这个问题了：在 32 位操作系统、4GB 物理内存的机器上，申请 8GB 内存，会怎么样？

因为 32 位操作系统，进程最多只能申请 3 GB 大小的虚拟内存空间，所以进程申请 8GB 内存，在申请虚拟内存阶段就会失败（我手上没有 32 位操作系统测试，我估计失败的原因是 OOM）。

在 64 位操作系统、4GB 物理内存的机器上，申请 8G 内存，会怎么样？

64 位操作系统，进程可以使用 128 TB 大小的虚拟内存空间，所以进程申请 8GB 内存是没问题的，因为进程申请内存是申请虚拟内存，只要不读写这个虚拟内存，操作系统就不会分配物理内存。

应用程序通过 malloc 函数申请内存的时候，实际上申请的是虚拟内存，此时并不会分配物理内存。

当应用程序读写了这块虚拟内存，CPU 就会去访问这个虚拟内存， 这时会发现这个虚拟内存没有映射到物理内存， CPU 就会产生缺页中断，进程会从用户态切换到内核态，并将缺页中断交给内核的 Page Fault Handler （缺页中断函数）处理。

缺页中断处理函数会看是否有空闲的物理内存：

如果有，就直接分配物理内存，并建立虚拟内存与物理内存之间的映射关系。
如果没有空闲的物理内存，那么内核就会开始进行回收内存的工作，如果回收内存工作结束后，空闲的物理内存仍然无法满足此次物理内存的申请，那么内核就会放最后的大招了触发 OOM （Out of Memory）机制。



在 32 位操作系统，因为进程最大只能申请 3 GB 大小的虚拟内存，所以直接申请 8G 内存，会申请失败。
在 64位 位操作系统，因为进程最大只能申请 128 TB 大小的虚拟内存，即使物理内存只有 4GB，申请 8G 内存也是没问题，因为申请的内存是虚拟内存，等这块虚拟内存被访问了，因为物理空间不够，就会发生 OOM。



### **jvm在什么时候进行标记**



### jwt的结构

**1 Header（头部）**

由令牌的类型（即JWT）和正在使用过的签名算法组成。如：

```javascript
{ 
    "alg": "HS256",
    "typ": "JWT" 
}
```



**2 Payload（负载）**



Payload是令牌jwt的第二部分。包含的是请求体和其它一些数据。

载荷的属性有三类：

预定义（Registered） 公有（public） 私有（private）



```javascript
{
 
    "sub": "1", 主题
    "iss": "http://localhost:8000/auth/login", 签发人
    "iat": 1451888119, 签发时间
    "exp": 1454516119, 过期时间
    "nbf": 1451888119, 生效时间，在此之前是无效的
    "jti": "37c107e4609ddbcc9c096ea5ee76c667", 编号
    "aud": "dev" 受众
}
```





**3 Signature（签名）**

签名属于jwt的第三部分。主要是把头部的base64UrlEncode与负载的base64UrlEncode拼接起来，再进行HMACSHA256加密，加密结果再进行base64url加密，最终得到的结果作为签名部分。

```javascript
base64url(     
    HMACSHA256(       
        base64UrlEncode(header) + "." + base64UrlEncode(payload),       
        your-256-bit-secret (秘钥加盐)     
    ) 
)
```



### 网络io模型

**4、用户空间和内核空间**

虚拟内存被操作系统划分成两块：内核空间和用户空间。为了安全，它们是隔离的，即使用户的程序崩溃了，内核也不受影响。

内核空间是内核代码运行的地方，用户空间是用户程序代码运行的地方。
当进程运行在内核空间时就处于内核态，当进程运行在用户空间时就处于用户态。

**5、同步和异步**

由于CPU和内存的速度远远高于外设的速度，所以在IO编程中，就存在速度严重不匹配的问题。

同步请求：A调用B，B的处理是同步的，在处理完之前他不会通知A，只有处理完之后才会明确的通知A。
异步请求：A调用B，B的处理是异步的，B在接到请求后先告诉A我已经接到请求了，然后异步去处理，处理完之后通过回调等方式再通知A。
同步和异步最大的区别就是被调用方的执行方式和返回时机。同步指的是被调用方做完事情之后再返回，异步指的是被调用方先返回，然后再做事情，做完之后再想办法通知调用方。

**6、阻塞和非阻塞**

阻塞请求：A调用B，A一直等着B的返回，别的事情什么也不干。
非阻塞请求：A调用B，A不用一直等着B的返回，先去忙别的事情了。
阻塞和非阻塞最大的区别就是在被调用方返回结果之前的这段时间内，调用方是否一直等待。阻塞指的是调用方一直等待别的事情什么都不做。非阻塞指的是调用方先去忙别的事情。

I/O 是分为两个过程的：

1. 数据准备的过程
2. 数据从内核空间拷贝到用户进程缓冲区的过程



**阻塞IO模型  （blocking IO）**

进程发起IO系统调用后，进程被阻塞，转到内核空间处理，整个IO处理完毕后返回进程，操作成功则进程获取到数据。

![img](https://img-blog.csdnimg.cn/img_convert/694be39c2749f98700567080f2b56154.png)



**非阻塞IO模型（non-blocking IO）** 

和上面的阻塞IO模型相比，非阻塞IO模型在内核数据没准备好，需要进程阻塞的时候，就返回一个错误，以使得进程不被阻塞。

- 进程发起IO系统调用后，如果内核缓冲区没有数据，需要到IO设备中读取，进程返回一个错误而不会被阻塞。
- 进程发起IO系统调用后，如果内核缓冲区有数据，内核就会把数据返回进程。

这种工作方式下需要不断轮询查看状态

![img](https://img-blog.csdnimg.cn/img_convert/7848d265b695b27b3175be6ffe1ff381.png)



非阻塞 IO优缺点：

同步非阻塞 IO 优点：每次发起 IO 调用，在内核等待数据的过程中可以立即返回，用户线程不会阻塞，实时性好

同步非阻塞 IO 缺点：多个线程不断轮询内核是否有数据，占用大量 CPU 资源，效率不高。一般 Web 服务器不会采用此模式



 **IO复用模型（IO multiplexing）**

多个的进程的IO可以注册到一个复用器(select)上，然后用一个进程调用该select,，select会监听所有注册进来的IO。

如果select监听的IO在内核缓冲区都没有可读数据，select调用进程会被阻塞；而当任一IO在内核缓冲区中有可读数据时，select调用就会返回；而后select调用进程可以自己或通知另外的进程(注册进程)来再次发起读取IO，读取内核中准备好的数据。
Linux中IO复用的实现方式主要有Select，Poll和Epoll：

Select：注册IO、阻塞扫描，监听的IO最大连接数不能多于FD_ SIZE（1024）。
Poll：原理和Select相似，没有数量限制，但IO数量大，扫描线性性能下降。
Epoll ：事件驱动不阻塞，mmap实现内核与用户空间的消息传递，数量很大，Linux2.6后内核支持。





IO multiplexing 这个词可能有点陌生，但是提到 select/epoll，大概就都能明白了。有些地方也称这种 IO 方式为事件驱动 IO(event driven IO)。我们都知道，**select/epoll 的好处就在于单个 process 就可以同时处理多个网络连接的 IO。它的基本原理就是 select/epoll 这个 function会不断的轮询所负责的所有 socket**，当某个 socket 有数据到达了，就通知用户进程。它的流程如图：



这个图和 blocking IO 的图其实并没有太大的不同，事实上还更差一些。因为这里需要使用两个系统调用(select 和 read)，而 blocking IO 只调用了一个系统调用(read)。但是使用 select 以后最大的优势是用户可以在一个线程内同时处理多个 socket 的 IO 请求。用户可以注册多个 socket，然后不断地调用 select 读取被激活的 socket，即可达到在同一个线程内同时处理多个 IO 请求的目的。而在同步阻塞模型中，必须通过多线程的方式才能达到这个目的。（多说一句：所以，如果处理的连接数不是很高的话，使用select/epoll 的 web server 不一定比使用 multi-threading + blocking IO 的 webserver 性能更好，可能延迟还更大。select/epoll 的优势并不是对于单个连接能处理得更快，而是在于能处理更多的连接。）


![img](https://img-blog.csdnimg.cn/img_convert/52b0f3b4ad496de74429c33850df28a2.png)



**信号驱动IO模型 （signal driven I/O）**

当进程发起一个IO操作，会向内核注册一个信号处理函数，然后进程返回不阻塞；当内核数据就绪时会发送一个信号给进程，进程便在信号处理函数中调用IO读取数据。

![在这里插入图片描述](https://img-blog.csdnimg.cn/20200605193656805.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjAwNjg4Mg==,size_16,color_FFFFFF,t_70)

  首先我们允许套接口进行信号驱动 I/O,并安装一个信号处理函数，进程继续运行并不阻塞。当数据准备好时，进程会收到一个 SIGIO 信号，可以在信号处理函数中调用 I/O 操作函数处理数据。当数据报准备好读取时，内核就为该进程产生一个 SIGIO 信号。我们随后既可以在信号处理函数中调用 read 读取数据报，并通知主循环数据已准备好待处理，也可以立即通知主循环，让它来读取数据报。无论如何处理 SIGIO 信号，这种模型的优势在于等待数据报到达(第一阶段)期间，进程可以继续执行，不被阻塞。免去了 select 的阻塞与轮询，当有活跃套接字时，由注册的 handler 处理。


**异步IO模型 （Asynchronous I/O）**

当进程发起一个IO操作，进程返回(不阻塞)，但也不能返回结果。内核把整个IO处理完后，会通知进程结果，如果IO操作成功则进程直接获取到数据。

![img](https://img-blog.csdnimg.cn/img_convert/787ff6e538868898f53a27e55bc30c62.png)

注意：
此模型和前面模型最大的区别是：***\*前4个从内核空间拷贝数据这一过程是阻塞的，需要自己把准备好的数据，放到用户空间。\****
而全异步不同，异步IO是「**内核数据准备好**」和「**数据从内核态拷贝到用户态**」这两个过程都不用等待。

用户线程完全不需要关心实际的整个IO操作是如何进行的，只需要先发起一个请求，当接收内核返回的成功信号时表示IO操作已经完成，可以直接去使用数据，它是最理想的模型。

### 线程池只有一个线程，抛异常会怎么样，worker状态

当一个线程池里面的线程异常后:

**1、当执行方式是execute时,可以看到堆栈异常的输出**

原因：ThreadPoolExecutor.runWorker()方法中，task.run()，即执行我们的方法，如果异常的话会throw x;所以可以看到异常。

**2、当执行方式是submit时,堆栈异常没有输出。但是调用Future.get()方法时，可以捕获到异常**

原因：ThreadPoolExecutor.runWorker()方法中，task.run()，其实还会继续执行FutureTask.run()方法，再在此方法中c.call()调用我们的方法，
如果报错是setException()，并没有抛出异常。当我们去get()时，会将异常抛出。

**3、不会影响线程池里面其他线程的正常执行**

**4、线程池会把这个线程移除掉，并创建一个新的线程放到线程池中**

当线程异常，会调用ThreadPoolExecutor.runWorker()方法最后面的finally中的processWorkerExit()，会将此线程remove，并重新addworker()一个线程。

**源码执行流程**

**execute源码执行流程**

1、开始执行任务，新增或者获取一个线程去执行任务(比如刚开始是新增coreThread去执行任务)。执行到task.run()时会去执行提交的任务。
   如果任务执行失败，或throw x抛出异常。
2、之后会到finally中的afterExecute()扩展方法，我们可以扩展该方法对异常做些什么。
3、之后因为线程执行异常会跳出runWorker的外层循环，进入到processWorkerExit()方法，此方法会将执行任务失败的线程删除，并新增一个线程。
4、之后会到ThreadGroup#uncaughtException方法，进行异常处理。
   如果没有通过setUncaughtExceptionHandler()方法设置默认的UncaughtExceptionHandler，就会在uncaughtException()方法中打印出异常信息。

**submit源码执行流程**

1、将传进来的任务封装成FutureTask，同样走execute的方法调用，然后直接返回FutureTask。
2、开始执行任务，新增或者获取一个线程去执行任务(比如刚开始是新增coreThread去执行任务)。
3、执行到task.run()时，因为是FutureTask，所以会去调用FutureTask.run()。
4、在FutureTask.run()中，c.call()执行提交的任务。如果抛出异常，并不会throw x，而是setException()保存异常。
5、当我们阻塞获取submit()方法结果时get()，才会将异常信息抛出。当然因为runWorker()没有抛出异常，所以并不会删除线程。

执行线程的方式有哪些，区别是什么。

### **创建线程方式**

```java
public static void test(){
        Thread thread = new Thread(){
            @Override
            public void run(){
                System.out.println("running");
            }
        };
        thread.start();
    }
}
```

```java
    public static void test2(){
        Runnable runnable = new Runnable() {
 
            @Override
            public void run() {
                System.out.println("running");
            }
        };
        Thread thread = new Thread(runnable);
        thread.start();
    }
```

- 两种方法一种是把线程和任务合并在了一起，另一种是把线程和任务分开
- 用Runnable更容易与线程池等高级API配合
- 用Runnable让任务类脱离了Thread继承体系，更灵活



重新Thread的run方法，覆盖掉原有的代码，runnable不会执行

```java
    @Override
    public void run() {
        if (target != null) {
            target.run(); // target就是runnable
        }
    }
```



get和post方法区别

get和post是http请求的两种方法，它们的区别在于：

1、GET请求通过URL（请求行）提交数据，在URL中可以看到所传参数。POST通过“请求体”传递数据，参数不会在url中显示

2、GET请求提交的数据有长度限制(url长度根据浏览器及服务器的不同而有不同限制。 若要支持IE的话，最大的长度为2083字符，若是中文字符的话只有2083/9=231个字符)，POST请求没有限制。

3、GET请求返回的内容可以被浏览器缓存起来。而每次提交的POST，浏览器在你按 下F5的时候会跳出确认框，浏览器不会缓存POST请求返回的内容。

4、GET对数据进行查询，POST主要对数据进行增删改！简单说，GET是只读，POST是写。

5、对于参数的数据类型，get只接受ASCII字符，而post没有限制。





大端模式和小段模式



数据分开



一棵二叉树有10个度为1的结点，7个度为2的结点，则该二叉树共有__个结点?

度为0的结点比度为2的结点多1个，故二叉树中结点总和为度为0的结点、度为1的结点、度为2的结点数三者相加，即8+10+7=25。