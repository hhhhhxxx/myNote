# 设计模式

## 一、六大设计原则

### 1.单一职责原则

A class or module should have a single responsibility。
一个类或者模块只负责完成一个职责（或者功能）

​		通俗点理解就是：**不要设计大而全的类，要设计粒度小、功能单一的类**。换个角度讲，一个类包含了两个或者两个以上业务不相干的功能，那我们就说它职责不够单一，应该将它拆分成多个功能更加单一、粒度更细的类。

### 2.里氏替换原则

所有引用基类的地方必须能透明地使用其子类的对象。

​		通俗点讲，只要父类能出现的地方子类就可以出现，而且替换为子类也不会产生任何错误或者异常，使用者可能根本就不需要知道是父类还是子类。但是，反过来就不行了，有子类的地方，父类未必就能适应。

### 3.依赖倒置原则

高层模块不应该依赖低层模块，两者都应该依赖其抽象（模块之间的依赖通过抽象发生，实现类之间不发生直接的依赖关系，其依赖关系通过接口或抽象类产生的）

抽象不应该依赖细节（接口或抽象类不依赖实现类）

细节应该依赖抽象（实现类依赖接口或者抽象类）

| 描述                 | 意义                                                         |
| :------------------- | :----------------------------------------------------------- |
| 抽象                 | 接口或抽象类                                                 |
| 细节                 | 实现类                                                       |
| 依赖关系（A依赖于B） | （1）类B以参数的形式传入类A的方法。<br/>（2）类B以局部变量的形式存在于类A的方法中。<br/>（3）类A调用类B的静态方法。 |

### 4.接口隔离原则

客户端不应该被强迫实现一些他们不会使用的接口，应该把胖接口中的方法分组，然后用多个接口替代它，每个接口服务于一个子模块。简单地说，就是使用多个专门的接口比使用单个接口要好很多。

### 5.迪米特法则

一个对象应该对其他对象有最少的了解。

通俗地讲，一个类应该对自己需要耦合或调用的类知道得最少，你（被耦合或调用的类）的内部是如何复杂都和我没关系，那是你的事情，我就知道你提供的这么多public方法，我就调用这么多，其他的我一概不关心。

### 6.开闭原则

一个软件实体如类、模块和函数应该对拓展开发，对修改关闭

老板定下了一套薪资计算体系，几年以来都是这么实行的。突然有天老板说：咱们扣掉10%基础薪资，然后作为绩效工资发放，干的好的领的比以前多，干的不好的。。。。。。大家能答应吗？大家会爽吗？

如果是应用下开闭原则，不能改只能增，那就是：大家以前的工资保持不变，我们新增绩效工资，干的好的多领钱！

拓展为继承原有接口，实现新的子类，重写方法。而不是把所有影响的类的修改。

## 二、23种设计模式



