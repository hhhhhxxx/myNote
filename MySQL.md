# MySQL

## 索引的设计和使用

### 索引概述

MyISAM和InnoDB存储的表默认创建的都是BTree索引。MySQL目前还不支持函数索引，但是之前前缀索引，即对索引字段的前N个字符创建索引。

MySQL还支持全文索引，该索引可以用于全文搜索，（5.0）只有MyISAM支持全文索引，只限于文本类型



MyISAM虽然也是B+树，但索引和数据是分开的。

1.myISAM会吧用户记录数据全部放在一个文件里，称为数据文件，这个文件不会划分若干页，有多少记录就往里面塞，通过每一行对应的行号快速访问，因为随意塞入，不会按主键大小排序，不能用二分查找法查找。

2.之后会把索引信息存储到另一个索引文件里，myISAM会单独为表的主键创建索引，只不过在叶子节点存储的不是用户记录数据，而是主键+行号，意味着找到到对应行号之后，会用行号去数据文件里再次找全部数据。所以myISAM每次查询都是必须要回表的，相当于二级索引。(innoDB的聚簇索引是直接在根目录记录页根据主键找到对应的内节点，在找到对应的底层叶子节点上的全部数据)。

3.有需要的话，也可以建立二级索引或者联合索引，只是叶子节点存放的是列值+行号。



### 设计索引的原则

1. **搜索的索引项，不一定是要选择的列。**换句话说，最适合索引的列是出现在Where句子中的列，或连接子句中指定的列，而不是出现在select 关键字后的选择列表中的列
2. **使用唯一索引。**考虑某列中值得分布，索引的列的基数越大，索引的效果越好。（性别就不适合，只有两种数据）
3. **使用短索引。**如果对字符串列进行索引，应该指定一个前缀长度，只要有可能就应该这样做。对前10个或20个字符进行索引能够节省大量索引空间，也可能使查询更快，较小的索引涉及的磁盘IO较小，较短的值比较起来更快。
4. **利用最左前缀，**（n个索引）可利用索引中最左边的列集来匹配行。
5. InnoDB存储引擎的表，记录默认会按一定的顺序保存。（有聚集索引 隐藏主键，用户设置了主键或唯一索引，就按照用户的顺序）





## 锁问题

MyISAM采用表级锁，innoDB支持行级锁，也支持表级锁，但默认情况下是采用行级锁。



### MySQL 3种锁的特性

1. 表级锁：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低。
2. 行级锁：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度最高。
3. 页面锁：开销和枷锁时间介于表锁和行锁之间；会出现死锁；锁定粒度介于表锁和行锁之间，并发度一般。



### 事务ACID属性

1. 原子性（Atomicity）：事务是一个原子操作单元，其对数据的修改，要么全都执行，要么全都不执行。
2. 一致性（Consistent）：在事务开始和完成时，数据都必须保持一致性状态。
3. 隔离性（Isolation）：数据库系统提供一定的隔离机制，保证事务在不受外部并发操作影响的独立环境执行。
4. 持久性（Durable）：事务完成后，它对于数据的修改是永久性的，即使出现系统故障也能保持。



### 并发事务处理带来的问题

1. **更新丢失**（同时更新）：当两个或多个事务选择同一行，然后基于最初选定的值更新该行，一个更新成功，一个失败（条件改变了）
2. **脏读**（一更新一读）：一个事务正在对一条记录做修改，在这个事务完成并提交前，这条记录的数据就处于不一致状态；这时，另一个事务读取同一条记录，读取了这些脏数据。
3. **不可重复读**（同一个事务读两次）：一个事务在读取某些数据后的某个时间，再次读取以前读过的数据，却发现其读出的数据已经发生了改变或某些数据已经被删除了（已经更新和删除）。
4. **幻读**：一个事务按相同的查询条件重新读取以前检索过的数据，却发现其他事务插入了满足其查询条件的新数据。（读多了）

### 事务隔离级别



### innoDB的行锁模式及加锁方法

1. 共享锁（S）：允许一个事务去读一行，阻止其他事务获得相同数据集的排他锁
2. 排他锁（X）：允许获得排他锁的事务更新，阻止其他事务获取相同数据集的共享锁和排他锁
3. 意向共享锁（IS）：事务打算给数据行加行共享锁，之前必须先取得该表的IS锁
4. 意向排他锁（IX）：事务打算给数据行加行排他锁，之前必须先取得该表的IX锁



意向锁的设计目的，只是为了方便上层资源检查下层资源是否有被占用的加速设计，本身并不能增加并发度。

例如事务B要给整个表加写锁，先查询意向锁，不用一行一行查就知道有没有其他事务再写入。

读或写不在同一行，可以同时读写，IS和IX可以兼容。

### innoDB行锁实现方式

Record lock（行锁）：对索引加锁。

Gap lock（间隙锁）：对索引项之间的“间隙”，第一条记录前的“间隙”或最后一条记录后的“间隙”加锁，（索引项可能不是连续增大的，存在空缺）

Next-key lock：前两种的组合，对记录及前面的间隙加锁。

### Next-Key锁

innoDB除了通过范围条件加锁时使用Next-Key锁外，如果使用相等条件请求给一个不存在的记录加锁，InnoDB也会使用Next-Key锁。

### 什么时候使用表锁

1. 第一种情况是：事务需要更新大部分或全部数据，表又比较大，如果使用默认的行锁，会有效率低，长时间等待和锁冲突问题
2. 第二种情况是：事务涉及多个表，比较复杂，很可能引起死锁，造成大量事务回滚。

### 关于死锁

避免死锁的方法

1. 如果不同的程序会并发存取多个表，应尽量约定以相同的顺序来访问表。（不同表按相同表顺序）
2. 在程序以批量方式处理数据的时候，如果事先对数据排序，保证每个线程按固定的顺序来处理数据。（同表按数据顺序）
3. 如果要更新记录，应该直接申请足够级别的索，即排他锁，而不应该申请共享锁。
4. 两个线程在RR级别下对相同条件加排他锁，没有记录的情况下，都会成功。导致两个都插入不了，将级别改为RC就可避免问题



## **MVCC**

### 什么是 MVCC ?

**`MVCC`**，全称 `Multi-Version Concurrency Control` ，即多版本并发控制。MVCC 是一种并发控制的方法，一般在数据库管理系统中，实现对数据库的并发访问，在编程语言中实现事务内存。

### 什么是当前读和快照读？

**当前读**
像 select lock in share mode (共享锁), select for update; update; insert; delete (排他锁)这些操作都是一种当前读，为什么叫当前读？就是它读取的是记录的最新版本，读取时还要保证其他并发事务不能修改当前记录，会对读取的记录进行加锁

**快照读**
像不加锁的 select 操作就是快照读，即不加锁的非阻塞读；快照读的前提是隔离级别不是串行级别，串行级别下的快照读会退化成当前读；之所以出现快照读的情况，是基于提高并发性能的考虑，快照读的实现是基于多版本并发控制，即 MVCC ,可以认为 MVCC 是行锁的一个变种，但它在很多情况下，避免了加锁操作，降低了开销；既然是基于多版本，即快照读可能读到的并不一定是数据的最新版本，而有可能是之前的历史版本

**说白了 MVCC 就是为了实现读-写冲突不加锁，而这个读指的就是`快照读`, 而非当前读，当前读实际上是一种加锁的操作，是悲观锁的实现**

### MVCC 能解决什么问题，好处是？

数据库并发场景有三种，分别为：

1. 读-读：不存在任何问题，也不需要并发控制

2. 读-写：有线程安全问题，可能会造成事务隔离性问题，可能遇到脏读，幻读，不可重复读

3. 写-写：有线程安全问题，可能会存在更新丢失问题，比如第一类更新丢失，第二类更新丢失

   

更新丢失

1. **第一类丢失更新(回滚丢失，Lost update)** 撤销一个事务的时候，把其它事务已提交的更新数据覆盖了。这是完全没有事务隔离级别造成的。如果事务1被提交，另一个事务被撤销，那么会连同事务1所做的更新也被撤销。

2. **第二类丢失更新(覆盖丢失/两次更新问题，Second lost update)** 当两个或多个事务查询相同的记录，然后各自基于查询的结果更新记录时会造成第二类丢失更新问题。每个事务不知道其它事务的存在，最后一个事务对记录所做的更改将覆盖其它事务之前对该记录所做的更改。

   

**MVCC 带来的好处是？**
多版本并发控制（MVCC）是一种用来解决读-写冲突的无锁并发控制，也就是为事务分配单向增长的时间戳，为每个修改保存一个版本，版本与事务时间戳关联，读操作只读该事务开始前的数据库的快照。 所以 MVCC 可以为数据库解决以下问题

在并发读写数据库时，可以做到在读操作时不用阻塞写操作，写操作也不用阻塞读操作，提高了数据库并发读写的性能
同时还可以解决脏读，幻读，不可重复读等事务隔离问题，但不能解决更新丢失问题

简而言之，MVCC 就是因为大佬们，不满意只让数据库采用悲观锁这样性能不佳的形式去解决读-写冲突问题，而提出的解决方案，所以在数据库中，因为有了 MVCC，所以我们可以形成两个组合：

MVCC + 悲观锁
MVCC解决读写冲突，悲观锁解决写写冲突
MVCC + 乐观锁
MVCC 解决读写冲突，乐观锁解决写写冲突
这种组合的方式就可以最大程度的提高数据库并发性能，并解决读写冲突，和写写冲突导致的问题



### MVCC 的实现原理

MVCC 的目的就是多版本并发控制，在数据库中的实现，就是为了解决`读写冲突`，它的实现原理主要是依赖记录中的 **`3个隐式字段`**，**`undo日志`** ，**`Read View`** 来实现的。

#### 隐式字段

每行记录除了我们自定义的字段外，还有数据库隐式定义的 DB_TRX_ID, DB_ROLL_PTR, DB_ROW_ID 等字段

**DB_TRX_ID：**6 byte，最近修改(修改/插入)事务 ID：记录创建这条记录/最后一次修改该记录的事务 ID
**DB_ROLL_PTR：**7 byte，回滚指针，指向这条记录的上一个版本（存储于 rollback segment 里）
**DB_ROW_ID：**6 byte，隐含的自增 ID（隐藏主键），如果数据表没有主键，InnoDB 会自动以DB_ROW_ID产生一个聚簇索引
实际还有一个删除 flag 隐藏字段, 既记录被更新或删除并不代表真的删除，而是删除 flag 变了

![image-20220730203454052](D:\Code\myNote\MySQL.assets\image-20220730203454052.png)
如上图，`DB_ROW_ID` 是数据库默认为该行记录生成的唯一隐式主键，`DB_TRX_ID` 是当前操作该记录的事务 ID ,而 `DB_ROLL_PTR` 是一个回滚指针，用于配合 undo日志，指向上一个旧版本



#### undo日志

undo log 主要分为两种：

**insert undo log**
	代表事务在 insert 新记录时产生的 undo log, 只在事务回滚时需要，并且在事务提交后可以被立即丢弃
**update undo log**
	事务在进行 update 或 delete 时产生的 undo log ; 不仅在事务回滚时需要，在快照读时也需要；所以不能随便删除，只有在快速读或事务回滚不涉及该日志时，对应的日志才会被 purge 线程统一清除

```xml
purge

从前面的分析可以看出，为了实现 InnoDB 的 MVCC 机制，更新或者删除操作都只是设置一下老记录的 deleted_bit ，并不真正将过时的记录删除。

为了节省磁盘空间，InnoDB 有专门的 purge 线程来清理 deleted_bit 为 true 的记录。为了不影响 MVCC 的正常工作，purge 线程自己也维护了一个read view（这个 read view 相当于系统中最老活跃事务的 read view ）;如果某个记录的 deleted_bit 为 true ，并且 DB_TRX_ID 相对于 purge 线程的 read view 可见，那么这条记录一定是可以被安全清除的。
```

不同事务或者相同事务的对同一记录的修改，会导致该记录的undo log成为一条记录版本线性表，既链表，undo log 的链首就是最新的旧记录，链尾就是最早的旧记录。



#### **Read View 读视图**

什么是 Read View?

什么是 Read View，说白了 Read View 就是事务进行快照读操作的时候生产的读视图 (Read View)，在该事务执行的快照读的那一刻，会生成数据库系统当前的一个快照，记录并维护系统当前活跃事务的 ID (当每个事务开启时，都会被分配一个 ID , 这个 ID 是递增的，所以最新的事务，ID 值越大)

所以我们知道 Read View 主要是用来做可见性判断的, 即当我们某个事务执行快照读的时候，对该记录创建一个 Read View 读视图，把它比作条件用来判断当前事务能够看到哪个版本的数据，既可能是当前最新的数据，也有可能是该行记录的undo log里面的某个版本的数据。

Read View遵循一个可见性算法，主要是将要**被修改的数据的最新记录中的 DB_TRX_ID**（即当前事务 ID ）取出来，与系统当前其他活跃事务的 ID 去对比（由 Read View 维护），如果 DB_TRX_ID 跟 Read View 的属性做了某些比较，不符合可见性，那就通过 DB_ROLL_PTR 回滚指针去取出 Undo Log 中的 DB_TRX_ID 再比较，即遍历链表的 DB_TRX_ID（从链首到链尾，即从最近的一次修改查起），直到找到满足特定条件的 DB_TRX_ID , 那么这个 DB_TRX_ID 所在的旧记录就是当前事务能看见的最新老版本

![image-20220730203921821](D:\Code\myNote\MySQL.assets\image-20220730203921821.png)

如上，它是一段 MySQL 判断可见性的一段源码，即 changes_visible 方法（不完全哈，但能看出大致逻辑），该方法展示了我们拿 DB_TRX_ID 去跟 Read View 某些属性进行怎么样的比较

在展示之前，我先简化一下 Read View，我们可以把 Read View 简单的理解成有三个全局属性

```xml
trx_list（名称我随意取的）
	一个数值列表
	用于维护 Read View 生成时刻系统 正活跃的事务 ID 列表
up_limit_id
	lower water remark
	是 trx_list 列表中事务 ID 最小的 ID
low_limit_id
	hight water mark
	ReadView 生成时刻系统尚未分配的下一个事务 ID ，也就是 目前已出现过的事务 ID 的最大值 + 1
	为什么是 low_limit ? 因为它也是系统此刻可分配的事务 ID 的最小值

```

1. 首先比较 DB_TRX_ID < up_limit_id , 如果小于Z（上一个修改的事务以提交），则当前事务能看到 DB_TRX_ID 所在的记录，如果大于等于进入下一个判断（上一个修改的事务还在进行中，不一致）
2. 接下来判断 DB_TRX_ID >= low_limit_id , 如果大于等于则代表 DB_TRX_ID 所在的记录在 Read View 生成后才出现的，那对当前事务肯定不可见，如果小于则进入下一个判断（当前事务开始在Read View之前）
3. 判断 DB_TRX_ID 是否在活跃事务之中，trx_list.contains (DB_TRX_ID)，如果在，则代表我 Read View 生成时刻，你这个事务还在活跃，还没有 Commit，你修改的数据，我当前事务也是看不见的；如果不在，则说明，你这个事务在 Read View 生成之前就已经 Commit 了，你修改的结果，我当前事务是能看见的

#### **RC , RR 级别下的 InnoDB 快照读有什么不同？**

正是 Read View 生成时机的不同，从而造成 RC , RR 级别下快照读的结果的不同

在 RR 级别下的某个事务的对某条记录的第一次快照读会创建一个快照及 Read View, 将当前系统活跃的其他事务记录起来，此后在调用快照读的时候，还是使用的是同一个 Read View，所以只要当前事务在其他事务提交更新之前使用过快照读，那么之后的快照读使用的都是同一个 Read View，所以对之后的修改不可见；
即 RR 级别下，快照读生成 Read View 时，Read View 会记录此时所有其他活动事务的快照，这些事务的修改对于当前事务都是不可见的。而早于Read View创建的事务所做的修改均是可见
而在 RC 级别下的，事务中，每次快照读都会新生成一个快照和 Read View , 这就是我们在 RC 级别下的事务中可以看到别的事务提交的更新的原因
总之在 RC 隔离级别下，是每个快照读都会生成并获取最新的 Read View；而在 RR 隔离级别下，则是同一个事务中的第一个快照读才会创建 Read View, 之后的快照读获取的都是同一个 Read View。