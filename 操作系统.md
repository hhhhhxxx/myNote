# 操作系统

## 进程的控制与描述 （线程）

### 进程的描述

#### 进程的定义（经典）：

1. 进程是程序的一次执行
2. 进程是一个程序及其数据在处理机上顺序执行时所发生的活动
3. 进程是具有独立功能的程序在一个数据集合上运行的过程，它是系统进行资源分配或调度的一个独立单位（传统定义，调度会改为线程）。



#### 进程控制块

为了使参与并发的每个程序（含数据）都能独立地运行，在操作系统中必须为之配置一个专门的数据结构，称为进程控制块

Process Control Block，系统利用PCB来描述进程的基本情况和活动过程，进而控制和管理进程。由程序段，相关的数据段和PCB三部分便构成了进程实体（进程映像）。一般情况，进程实体就是进程，创建和撤销进程就是创建和撤销PCB



#### 进程的特征

1. 动态性：进程实体具有一定的生命期
2. 并发性：多个进程实体同存于内存中，且能在一段时间内同时运行
3. 独立性：传统os中，进程实体是一个能独立运行，独立获取资源和独立接收调度（后面是线程）的基本单位。
4. 异步性：进程是按异步方式运行，按各自独立，不可预知的速度向前推进。



### 进程的基本状态及转换

#### 进程的三种基本状态

1. 就绪Ready
2. 执行Running
3. 阻塞Block

#### 创建状态和终止状态

为了满足进程控制块对数据及完整性要求以及增强管理的灵活，通常在系统中又为进程引入了两种常见的状态：创建状态和终止状态。



### 进程控制

#### 进程的创建

操作系统Create原语步骤

1. 申请空白PCB,为新进程申请获得唯一的数字标识符，并从PCB集合中索取一个空白的PCB
2. 为新进程分配其运行所需的资源，包括各种物理资源和逻辑资源，如内存，文件，IO设备和CPU时间。
3. 初始化进程控制块（PCB）
   1. 初始化标识信息，将系统分配的标识符和父进程标识填入PCB
   2. 初始化处理机状态信息，使程序计数器指向程序的入口地址，使栈指针指向栈顶
   3. 初始化处理机控制信息，将进程的状态设置为就绪或静止就绪状态，默认设置最低优先级
4. 如果进程就绪队列能够接纳新进程，便将新进程插入就绪队列。



#### 进程的终止

引起进程终止的事件

1. 正常结束，表示进程的任务已经完成，准备退出运行。
2. 异常结束，是指进程在运行时发生了某种异常事件，使程序无法继续运行。
3. 外界干预，是指进程应外界的请求而终止运行。

终止原语步骤

1. 根据被终止进程的标识符，从PCB集合中检索出该进程的PCB，从中读出该进程的状态
2. 若被终止进程正处于执行状态，应立即终止该进程的执行，并置调度标识为真，用于指示该进程被终止后应重新进行调度
3. 若该进程还有子孙进程，还应将其所有子孙进程也都予以终止，以防止它们成为不可控的进程
4. 将被终止进程所拥有的全部资源归还给其父进程，或者归还给系统
5. 将被终止进程（PCB）从所在队列（或者链表）中移除，等待其他程序来搜集信息。



#### 进程的阻塞与唤醒

引起进程阻塞和唤醒的事件

1. 向系统请求共享资源失败。无足够资源，阻塞，其他进程释放资源，该进程被唤醒。
2. 完成某种操作的完成。启动了某IO设备，IO操作完成将进程唤醒
3. 新数据尚未到达，对于相互合作的进程，如果一个进程需要先获得另一进程提供的数据后才能对该数据进行处理。
4. 等待新任务的到达。在网络环境中的发送进程，无新的数据包发送就把自己阻塞起来。



进程阻塞过程

block原语

1. 处于执行状态的进程立即停止执行
2. 把PCB中的现行状态由执行改为阻塞
3. 将PCB插入阻塞队列
4. 调度程序重新调度

进程唤醒过程

wakeup原语

1. 把被阻塞的进程从等待该事件的阻塞队列中移出
2. PCB中的现行状态由阻塞改为就绪
3. 将PCB加入就绪队列

#### 进程的挂起与激活

进程的挂起

suspend原语

1. 首先检查被挂起进程的状态，活动就绪状态改为静止就绪，活动阻塞改为静止阻塞
2. 把PCB复制到某指定内存区域，方便用户和父进程考查该进程运行情况

进程的激活

active原语

1. 将进程从外存调入内存
2. 检查现行状态，静止就绪改为活动就绪，静止阻塞改为活动阻塞
3. 重新调度（继续运行当前进程或者运行刚激活的进程）



### 进程同步 

#### 进程同步的基本概念

**两种形式的制约关系**

1. 间接相互制约关系：例如多个进程只能互斥访问
2. 直接相互制约关系：相互合作，共享缓冲区，缓冲区有输入，才能有输出



**临界资源**

打印机，磁带机等，诸进程间应采取互斥方式实现对这种资源的共享



**生产者消费者问题**

有一群生产者进程在生成产品，并将这些产品提供给消费者进程去消费。生产者和消费者都是异步方式执行，但是它们之间必须保持同步（数据一致，生成n个最多消费n个）



**临界区**

不论是硬件临界资源还是软件临界资源，多个进程必须互斥地对它进行访问，每个进程中访问临界资源的那段代码成为临界区



```java
// 生产者消费者中
while(true) {
    进入区（检查是否能访问）
    临界区
    退出区（将临界资源正被访问的标志恢复为未被访问的标志）
	剩余区（剩下的代码叫剩余区）
}
```



**同步机制应遵循的规则**

1. 空闲让进，无进程进入临界区时，应允许一个请求进入临界区的进程立即进入自己的临界区
2. 忙则等待，已有进程进入临界区时，其他试图进入临界区的进程必须等待
3. 有限等待，保证在有限时间内能进入自己的临界区，以免陷入死等状态
4. 让权等待，进程不能进入临界区，应立即释放处理机，以免陷入忙等状态



#### **信号量机制**

信号量机制是一种卓有成效的进程同步机制

**1.整型信号量**

定义为一个用于表示资源数目的整型量S，仅能通过两个标准的原子操作**wait(S)**和**signal(S)**来访问，这两个操作一直被称为PV操作

```java
wait(S) {
    while(S <= 0); // 等待S>0
    S--;
}

sinal(S) {
	S++; // 释放资源
}
```



**2.记录型信号量**

不存在“忙等”现象的同步机制

```java
wait(semaphor *S) {
	S->value--; 
    if(S->value < 0) block(S->list); // 加入阻塞队列
}

signal(semaphor *S) {
	S->value++;
    if(S->value <= 0) wakeup(S->list); // 唤醒一个阻塞的进程
}
```



**3.AND型信号量**

表示多个共享资源

将进程在整个运行过程中需要的所有资源，一次性全部分配给进程，待进程使用完后再一起释放。（差一个资源也不分配，防止死锁）

```java
if(S1 >= 1 && ... && Sn > = 1) {
	for(int i=1;i<=n;i++) Si--;
	break;
} else {
	// 申请失败
}
```



**4.信号量集**

对比记录型信号量，避免进行N次wait(S)。此外，为确保系统的安全性，当所申请的资源数量低于某一下限值时，还必须进行管制，不予分配。

对AND信号量机制加以扩充

进程对信号量Si的测试值不再是1，而是该资源的分配下限ti，即要求Si>=ti，否则不予分配。一旦允许分配，进程对该资源的需求值为di，即表示资源占用量，进行Si = Si - di操作



```java
Swait(S1,t1,di,...,Sn,tn,dn)
 // S 现在资源的剩余量
 // t 要求现在大于等于t才分配
 // d 分配的量
```



#### 管程机制

代表共享资源的数据结构以及由对共享数据结构实施的一组过程所组成的资源管理程序共同构成了一个操作系统的资源管理模块

管程组成

1. 管程的名称
2. 局部于管程的共享数据结构说明
3. 对该数据结构进行操作的一组过程
4. 对局部于管程的共享数据设置初始值的语句



#### 经典同步问题

##### 生成者消费者

记录型信号量解决

假定在生产者和消费者之间的公用缓冲池中具有n个缓冲区，这时可以利用互斥信号量mutex实现诸对缓冲池的互斥使用，利用信号量empty和full分别表示缓冲池中空缓冲区和满缓冲区的数量。

```java
// full + empty = n
// mutex = {1,0} 表示互斥
void proceducer() {
    wait(empty); // empty--
    wait(mutex);
    buffer[in] = nextp;
    in = (in+1)%n
    signal(mutex); 
    signal(full); // full++
}

void consumer() {
    wait(full); // full--
    wait(mutex);
    nextp = buffer[out];
    out = (out+1)%n
    signal(mutex); 
    signal(empty); // empty++
}
```

##### 哲学家进餐问题

五个哲学家共用一张圆桌，分别坐在周围的五张椅子上，在圆桌撒花姑娘有5个碗和5只筷子，他们的生活方式是交替地进行思考和进餐。一个哲学家进行思考，饥饿时便试图取用左右最靠近他的筷子，只有在他拿到两只筷子时才能进行进餐，进餐完毕，放下筷子继续思考



可能引起死锁：每个人都先拿左边的筷子，所有人都只有一个筷子，没有人能成功进餐。



解决方法：

- 至多只允许4位哲学家同时去拿左边的筷子，最终能保证至少有一位哲学家能够进餐。
- 仅当哲学家的左右筷子均可用是，才允许他拿起筷子进餐（and信号量）
- 规定奇数号哲学家先拿他左边的筷子，然后再拿右边的，偶数号相反（相当于简化成只竞争一个资源）



```java
semaphore chopstick chopstick[5] = {1,1,1,1,1}

// and信号量 同时申请两个
Sswait(chopstick[(i+1)%5],chopstick[i])
    
Ssignal(chopstick[(i+1)%5],chopstick[i])
```



##### 读者写者问题

允许多个进程同时读一个共享对象（共享），但不允许写进程与其他进程同时访问共享对象（排他）

```java
// 信号量集 params: S t d

int RN;
semaphore L = RN , mx = 1;

void reader() {
    Swait(L,1,1) // 读者这里分开 而且互斥信号量不扣，实现多个读者共享
    Swait(mx,1,0)
    
    Ssignal(L,1)
}


void writer() {
    Swait(mx,1,1,L,RN,0); // 写者这里是and 要求两个同时满足，L的需求是RN（最大，标识没有读，也没有写，空闲状态） 实现互斥
    
    Ssignal(mx,1)
}
```



### 进程通信

#### 进程通信类型

1. 共享存储器系统
   - **基于共享数据结构的通信方式：**生产者消费者的有界缓冲区，操作系统提供存储器，程序员负责对公用数据结构的设置及对进程    间同步的处理
   - **基于共享存储区的通信方式：**在内存中划出一块共享存储区域，进程可通过对该共享区的读或写交换信息，进程负责实现通信，访问控制等，不是OS
2. 管道(pip)通信系统：连接一个读纪进程和一个写进程以实现它们通信的一个共享**文件**
3. 消息传递系统：不必借助任何共享存储器和数据结构，而是是格式化的消息为单位。计算机网络中，消息又称报文
4. 客户机服务器系统
   - 套接字（Socket）：网络通信程序接口
   - 远程过程调用和远程方法调用：调用另一台主机上的进程



消息传递通信的实现方式

1.直接消息传递系统

send(receiver,message)

receive(sender,message)

2.信箱系统



### 线程的基本概念

操作系统中引入线程则是为了减小程序在并发执行时所付出的时空开销，使OS具有更好的并发性

线程称之为轻型进程（Light-Weight Process）



线程实现方式

1.内核支持线程KST

2.用户级线程ULT

3.组合方式ULT/KST